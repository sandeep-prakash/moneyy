package com.prakashs;

import javax.swing.filechooser.FileNameExtensionFilter;
import javax.tools.JavaCompiler;
import java.io.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.Format;
import java.util.*;
import java.sql.DriverManager;
import java.text.SimpleDateFormat;
import java.util.Formatter;
import java.util.logging.*;

/**
 * Created by IntelliJ IDEA.
 * User: Sandeep Prakash
 * Date: 27/08/11
 * Time: 03:45
 *
 * EODDataHandler takes the log file generated by the NSE Stream Capture utility and uploads tick (?)
 * data to a database
 */
public class EODDataHandler {

    // Driver info
    private final static String DRIVER_CLASS = "org.postgresql.Driver";
    private final static String JDBC_URL = "jdbc:postgresql://localhost/mdata";
    private final static String USER_ID = "postgres";
    private final static String PASSWORD = "p@ssw0rd";

//    private final static String DRIVER_CLASS = "org.sqlite.JDBC";
//    private final static String JDBC_URL = "jdbc:sqlite:C:/Users/sanprakash/sqlite3/mdata";
//    private final static String USER_ID = "";
//    private final static String PASSWORD = "";

    private final static Logger __logger = Logger.getLogger(EODDataHandler.class.getName());
    private final static SimpleDateFormat __dateParser = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy");
    private static Connection __connection;

    // Statements
    private final static String INSERT_KEY_STMT = "select insert_key(?,?)";
    private final static String BULK_COPY_STMT = "copy %s from '%s' with delimiter ','";
    private final static String INSERT_FILE_NAME = "insert into file_list values(?)";

    // Other private data
    // instrument,tick,bid,bid_qty,ask,ask_qty
    private BufferedReader fileReader;
    private long startTick;
    private HashMap<String, Long> instrumentLastTick;
    private HashMap<String, TickData> instrumentLastLine;
    private File instrumentBulkFile;
    private File indexBulkFile;

    public static void main(String[] args) {
        Logger.getLogger("").setLevel(Level.ALL);
        __logger.setLevel(Level.ALL);
        try{
            long startTime = new Date().getTime();
            File file = new File(args[0]);
            if(file.isDirectory()){
                File[] files = file.listFiles();
                for(File f : files){
                    __logger.info("Processing file " + f.getAbsolutePath());
                    new EODDataHandler().loadData(f.getAbsolutePath());
                }
            }else{
                new EODDataHandler().loadData(args[0]);
            }

            __logger.info("Time taken = " + (new Date().getTime() - startTime) + " ms.");
        }catch(Exception ex){
            __logger.throwing(EODDataHandler.class.getName(), "main", ex);
            ex.printStackTrace();
        }

    }

    //
    // Loads file_
    //
    public void loadData(String file_) throws Exception{
        __logger.entering(EODDataHandler.class.getName(), "loadData");

        String fileName = new File(file_).getName();

        startTick = new SimpleDateFormat("MMM-dd-yy").parse(fileName.substring(4,13)).getTime() + 33300*1000;

        __logger.info("Will build a connection now...");
        buildConnection();

        // Initialize file reader
        fileReader = new BufferedReader(new FileReader(file_));

        // Initialize file writer
        instrumentBulkFile = new File(file_+".out");
        indexBulkFile = new File(file_+".index.out");

        // Data Structures
        instrumentLastTick = new HashMap<String, Long>();
        instrumentLastLine = new HashMap<String, TickData>();

        initialize();
        loadTickData();
        PreparedStatement pStmt = __connection.prepareStatement(INSERT_FILE_NAME);
        pStmt.setString(1, fileName.substring(4,13));
        pStmt.executeUpdate();

        __connection.commit();
        __connection.close();
        fileReader.close();

        __logger.info("DONE...");
    }

    private void buildConnection() throws Exception{
		try {
			Class.forName(DRIVER_CLASS);
		} catch(java.lang.ClassNotFoundException e) {
			__logger.throwing(EODDataHandler.class.getName(), "buildConnection", e);
        }
		__connection = DriverManager.getConnection(JDBC_URL, USER_ID, PASSWORD);
        __connection.setAutoCommit(false);
	}

    private void initialize() throws Exception {
        __logger.info("Entering initialize");
        PreparedStatement keyLoaderStmt = __connection.prepareStatement(INSERT_KEY_STMT);

        String line = null;

        while((line = fileReader.readLine()) != null) {
            String[] values = line.trim().split(",");
            if(values.length == 5) {
                __connection.commit();
                break;
            }

            if(values.length == 4) {
                keyLoaderStmt.setString(1, values[1]);
				keyLoaderStmt.setString(2, values[2]);
				keyLoaderStmt.executeQuery();
            }
        }

        __logger.exiting(EODDataHandler.class.getName(), "initialize");
    }

    private void loadTickData() throws Exception {
        __logger.info("Entering loadTickData...");

        String line = null;
        long rows = 0;

        // Write file.
        FileWriter fileWriter = new FileWriter(instrumentBulkFile);
        FileWriter idxWriter = new FileWriter(indexBulkFile);
        while((line = fileReader.readLine()) != null) {
            String[] values = line.trim().split(",");

            if(values.length != 5 && values.length != 13) continue;

            long tick = __dateParser.parse(values[0]).getTime();

            if(values.length == 5) {
                if(tick < startTick + 22500*1000) writeIndexTickToFile(values, tick, idxWriter);
            }

            if(values.length == 13) {
                if(tick < startTick + 22500*1000) writeInstrumentTickToFile(values, tick, fileWriter);
                if(rows % 10000 == 0){
                    __logger.info(rows + " Rows processed.");
                }
            }

            rows++;
        }

        fileWriter.close();
        idxWriter.close();

        loadPGCSVFiles();
        //loadSQLiteCSVFiles();

        // Insert file name

        // Cleanup

        __logger.exiting(EODDataHandler.class.getName(), "loadTickData");
    }

    private void loadPGCSVFiles() throws SQLException {
        String copyStmt = new Formatter().format(BULK_COPY_STMT, "instrument_data",
                                             instrumentBulkFile.getAbsolutePath()).out().toString();
        copyStmt = doubleSlashFileName(copyStmt);
        __logger.info("Instrument Copy statement is " + copyStmt);
        // Copy Instrument file to table
        __connection.createStatement().executeUpdate(copyStmt);

        copyStmt = new Formatter().format(BULK_COPY_STMT, "index_data",
                                             indexBulkFile.getAbsolutePath()).out().toString();
        copyStmt = doubleSlashFileName(copyStmt);
        __logger.info("Instrument Copy statement is " + copyStmt);

        // Copy Index file to table
        __connection.createStatement().executeUpdate(copyStmt);
    }

    private void loadSQLiteCSVFiles() throws SQLException {
        String copyStmt = new Formatter().format(".import %s %s",
                                             instrumentBulkFile.getAbsolutePath(), "instrument_data").out().toString();
        //copyStmt = doubleSlashFileName(copyStmt);
        __logger.info("Instrument Copy statement is " + copyStmt);
        // Copy Instrument file to table
        __connection.createStatement().executeUpdate(copyStmt);


    }


    private String doubleSlashFileName(String copyStmt) {
        copyStmt = copyStmt.replaceAll("\\\\","\\\\\\\\");
        return copyStmt;
    }

    private void writeIndexTickToFile(String[] values, long tick, FileWriter fileWriter) throws Exception {
        float indexValue = Float.parseFloat(values[4]);
        String indexName = values[2];

        TickData indexData = new TickData();
        indexData.ask = indexValue;

        if(instrumentLastTick.containsKey(indexName)) {
            long lastTick = instrumentLastTick.get(indexName);
            float lastIndexValue = instrumentLastLine.get(indexName).ask;
            while(lastTick < tick - 1000){
                lastTick = lastTick + 1000;
                String aLine = new StringBuffer(indexName).append(",").append(lastTick).append(",").
                                append(lastIndexValue).append("\n").toString();
                fileWriter.write(aLine);
            }
        }

        String line = new StringBuffer(indexName).append(",").append(tick).append(",").
                            append(indexValue).append("\n").toString();
        long lastTick = 0;
        if(instrumentLastTick.containsKey(indexName)) lastTick = instrumentLastTick.get(indexName);
        instrumentLastTick.put(indexName, tick);
        instrumentLastLine.put(indexName, indexData);

        if(lastTick != tick) fileWriter.write(line);
    }


    private void writeInstrumentTickToFile(String[] values, long tick, FileWriter fileWriter) throws Exception {
        TickData tickInfo = new TickData();
        tickInfo.bid = Float.parseFloat(values[4]);
        tickInfo.bidQty = Float.parseFloat(values[5]);
        tickInfo.ask = Float.parseFloat(values[6]);
        tickInfo.askQty = Float.parseFloat(values[7]);

        TickData lastLine = instrumentLastLine.get(values[2]);
        if(lastLine != null){
            if(tickInfo.bid < 0) tickInfo.bid = lastLine.bid;
            if(tickInfo.bidQty < 0) tickInfo.bidQty = lastLine.bidQty;
            if(tickInfo.ask < 0) tickInfo.ask = lastLine.ask;
            if(tickInfo.askQty < 0) tickInfo.askQty = lastLine.askQty;
        }

        String line = new StringBuffer(values[2]).append(",").append(tick).append(",").
                append(tickInfo).append("\n").toString();

        if(instrumentLastTick.containsKey(values[2])) {
            long lastTick = instrumentLastTick.get(values[2]);

            while(lastTick < tick - 1000){
                lastTick = lastTick + 1000;
                String aLine = new StringBuffer(values[2]).append(",").append(lastTick).append(",").
                                append(lastLine).append("\n").toString();
                fileWriter.write(aLine);
            }
        }

        long lastTick = 0;
        if(instrumentLastTick.containsKey(values[2])) lastTick = instrumentLastTick.get(values[2]);
        instrumentLastTick.put(values[2], tick);
        instrumentLastLine.put(values[2], tickInfo);

        if(lastTick != tick) fileWriter.write(line);
    }
}

class TickData{
    public float bid;
    public float bidQty;
    public float ask;
    public float askQty;

    public String toString(){
        return new StringBuffer().append(bid).append(",").append(bidQty).append(",").append(ask).append(",").
                append(askQty).toString();
    }
}